local a = require(script.lexer) local b = table.create(7) local c = table.create(7) local d = table.create(3) local function e(_) return string.gsub( string.gsub(string.gsub(string.gsub(string.gsub(_, "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), '"', "&quot;"), "'", "&apos;" ) end local function _(_) return string.gsub(_, "\t", "    ") end local function f(_) return string.gsub(_, "[\0\1\2\3\4\5\6\7\8\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31]+", "") end local function g(h, i) i = _(f(i or h.Text)) h.RichText = false h.Text = i h.TextXAlignment = Enum.TextXAlignment.Left h.TextYAlignment = Enum.TextYAlignment.Top h.BackgroundColor3 = b.background h.TextColor3 = b.iden h.TextTransparency = 0.5 local f = h.TextSize local _, _ = string.gsub(i, "\n", "") _ += 1 local j = d[h] if not j then j = table.create(_) for _ = 1, _ do local a = Instance.new("TextLabel") a.Name = "Line_" .. _ a.RichText = true a.BackgroundTransparency = 1 a.TextXAlignment = Enum.TextXAlignment.Left a.TextYAlignment = Enum.TextYAlignment.Top a.TextColor3 = b.iden a.Font = h.Font a.TextSize = f a.Size = UDim2.new(1, 0, 0, f) a.Position = UDim2.fromOffset(0, (f * h.LineHeight) * (_ - 1)) a.Text = "" a.Parent = h j[_] = a end elseif #j < _ then for _ = #j + 1, _ do local a = Instance.new("TextLabel") a.Name = "Line_" .. _ a.RichText = true a.BackgroundTransparency = 1 a.TextXAlignment = Enum.TextXAlignment.Left a.TextYAlignment = Enum.TextYAlignment.Top a.TextColor3 = b.iden a.Font = h.Font a.TextSize = f a.Size = UDim2.new(1, 0, 0, f) a.Position = UDim2.fromOffset(0, (f * h.LineHeight) * (_ - 1)) a.Text = "" a.Parent = h j[_] = a end elseif #j > _ then for _ = #j, _, -1 do j[_].Text = "" end end local k, l, g = {}, 0, 1 for f, _ in a.scan(i) do local a = b[f] or b.iden local _ = string.split(e(_), "\n") for _, e in ipairs(_) do if _ > 1 then j[g].Text = table.concat(k) g += 1 l = 0 table.clear(k) end l += 1 if a ~= b.iden and string.find(e, "[%S%C]") then k[l] = string.format(c[f], e) else k[l] = e end end end j[g].Text = table.concat(k) d[h] = j local _ _ = h.AncestryChanged:Connect(function() if h.Parent then return end d[h] = nil _:Disconnect() end) return function() for _, _ in ipairs(j) do _:Destroy() end table.clear(j) d[h] = nil _:Disconnect() end end local function _(_) b.scripts = (_ and _.scripts) or Color3.fromRGB(241, 107, 138) b.background = (_ and _.background) or Color3.fromRGB(47, 47, 47) b.iden = (_ and _.iden) or Color3.fromRGB(234, 234, 234) b.keyword = (_ and _.keyword) or Color3.fromRGB(215, 174, 255) b.builtin = (_ and _.builtin) or Color3.fromRGB(131, 206, 255) b.string = (_ and _.string) or Color3.fromRGB(196, 255, 193) b.number = (_ and _.number) or Color3.fromRGB(255, 125, 125) b.comment = (_ and _.comment) or Color3.fromRGB(140, 140, 155) b.operator = (_ and _.operator) or Color3.fromRGB(255, 239, 148) for _, a in pairs(b) do c[_] = '<font color="#' .. string.format("%.2x%.2x%.2x", a.R * 255, a.G * 255, a.B * 255) .. '">%s</font>' end for a, _ in pairs(d) do for _, _ in ipairs(_) do _.TextColor3 = b.iden end g(a) end end pcall(_) return setmetatable({ UpdateColors = _, Highlight = g }, { __call = function(_, _, a) return g(_, a) end, })